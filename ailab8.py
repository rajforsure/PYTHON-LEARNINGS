# -*- coding: utf-8 -*-
"""AiLAB8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FUn1-F_9MVNs8MuP-3b5KYQq6NYtKfud
"""

import heapq
import math
import matplotlib.pyplot as plt

# A* Search Algorithm
def a_star_search(grid, start, goal, heuristic):
    rows, cols = len(grid), len(grid[0])
    open_set = []
    heapq.heappush(open_set, (0, start))
    came_from = {}
    g_score = {start: 0}
    f_score = {start: heuristic(start, goal)}
    visited_nodes = 0

    while open_set:
        _, current = heapq.heappop(open_set)
        visited_nodes += 1

        if current == goal:
            return reconstruct_path(came_from, current), visited_nodes

        for neighbor in get_neighbors(grid, current):
            tentative_g_score = g_score[current] + 1  # Uniform cost for each step
            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)
                heapq.heappush(open_set, (f_score[neighbor], neighbor))

    return None, visited_nodes


# BFS Algorithm
def bfs(grid, start, goal):
    queue = [start]
    came_from = {}
    visited = set()
    visited.add(start)
    visited_nodes = 0

    while queue:
        current = queue.pop(0)
        visited_nodes += 1

        if current == goal:
            return reconstruct_path(came_from, current), visited_nodes

        for neighbor in get_neighbors(grid, current):
            if neighbor not in visited:
                queue.append(neighbor)
                visited.add(neighbor)
                came_from[neighbor] = current

    return None, visited_nodes


# Uniform Cost Search Algorithm
def uniform_cost_search(grid, start, goal):
    open_set = []
    heapq.heappush(open_set, (0, start))
    came_from = {}
    cost_so_far = {start: 0}
    visited_nodes = 0

    while open_set:
        _, current = heapq.heappop(open_set)
        visited_nodes += 1

        if current == goal:
            return reconstruct_path(came_from, current), visited_nodes

        for neighbor in get_neighbors(grid, current):
            new_cost = cost_so_far[current] + 1  # Uniform cost for each step
            if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]:
                cost_so_far[neighbor] = new_cost
                priority = new_cost
                heapq.heappush(open_set, (priority, neighbor))
                came_from[neighbor] = current

    return None, visited_nodes


# Helper Functions
def get_neighbors(grid, node):
    x, y = node
    neighbors = []
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # No diagonal movement
    for dx, dy in directions:
        nx, ny = x + dx, y + dy
        if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 0:
            neighbors.append((nx, ny))
    return neighbors


def reconstruct_path(came_from, current):
    path = [current]
    while current in came_from:
        current = came_from[current]
        path.append(current)
    path.reverse()
    return path


# Heuristics
def manhattan_distance(node1, node2):
    return abs(node1[0] - node2[0]) + abs(node1[1] - node2[1])


def euclidean_distance(node1, node2):
    return math.sqrt((node1[0] - node2[0]) ** 2 + (node1[1] - node2[1]) ** 2)


# Visualization Function
def visualize_path(grid, path):
    grid_copy = [[cell for cell in row] for row in grid]

    for x, y in path:
        grid_copy[x][y] = '*'

    plt.imshow(grid_copy, cmap='gray_r')
    plt.title("Path Visualization")
    plt.show()


# Main Function to Compare Algorithms
def main():
    # Define the grid (0: free space; 1: obstacle)
    grid = [
        [0, 0, 0, 0],
        [1, 1, 0, 1],
        [0, 0, 0, 0],
        [0, 1, 1, 0],
        [0, 0, 0, 0]
    ]

    start = (4, 0)   # Starting position
    goal = (0, 3)   # Goal position

    print("A* Search with Manhattan Distance:")
    path_a_star_manhattan, nodes_a_star_manhattan = a_star_search(grid, start, goal,
                                                                  manhattan_distance)

    print("Path:", path_a_star_manhattan)
    print("Nodes Explored:", nodes_a_star_manhattan)


main()