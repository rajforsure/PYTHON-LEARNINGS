# -*- coding: utf-8 -*-
"""AiLAB5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zHs8iE5ifj7hxQOza-ukbJrSp21-iLl7
"""

import heapq
from collections import deque

def uniform_cost_search(graph, start, goal):
    """
    Perform Uniform Cost Search to find the minimum-cost path in a weighted graph.
    :param graph: Dictionary representing the adjacency list of the weighted graph.
    :param start: Starting node.
    :param goal: Goal node.
    :return: Tuple (path, cost) representing the optimal path and its cost.
    """
    # Priority queue for UCS (min-heap)
    priority_queue = []
    heapq.heappush(priority_queue, (0, start))  # (cost, node)

    visited = set()  # To keep track of visited nodes
    parents = {}  # To reconstruct the path
    costs = {start: 0}  # To store the cost of reaching each node

    while priority_queue:
        current_cost, current_node = heapq.heappop(priority_queue)

        if current_node in visited:
            continue
        visited.add(current_node)

        # Check if goal is reached
        if current_node == goal:
            path = []
            while current_node:
                path.append(current_node)
                current_node = parents.get(current_node)
            return path[::-1], current_cost

        # Explore neighbors
        for neighbor, weight in graph.get(current_node, []):
            new_cost = current_cost + weight

            if neighbor not in costs or new_cost < costs[neighbor]:
                costs[neighbor] = new_cost
                heapq.heappush(priority_queue, (new_cost, neighbor))
                parents[neighbor] = current_node

    return None, float('inf')  # Return None if no path is found


def breadth_first_search_unweighted(graph, start, goal):
    """
    Perform Breadth-First Search to find the shortest path in an unweighted graph.
    :param graph: Dictionary representing the adjacency list of the graph.
    :param start: Starting node.
    :param goal: Goal node.
    :return: List representing the shortest path.
    """
    queue = deque([start])
    visited = set()
    parents = {}

    while queue:
        current_node = queue.popleft()

        if current_node in visited:
            continue
        visited.add(current_node)

        # Check if goal is reached
        if current_node == goal:
            path = []
            while current_node:
                path.append(current_node)
                current_node = parents.get(current_node)
            return path[::-1]

        # Explore neighbors
        for neighbor, _ in graph.get(current_node, []):
            if neighbor not in visited and neighbor not in queue:
                queue.append(neighbor)
                parents[neighbor] = current_node

    return None  # Return None if no path is found


def compare_ucs_and_bfs(graph, start, goal):
    """
    Compare Uniform Cost Search and Breadth-First Search for a graph.
    """
    print("Running Uniform Cost Search...")
    ucs_path, ucs_cost = uniform_cost_search(graph, start, goal)
    print(f"UCS Path: {ucs_path}")
    print(f"UCS Cost: {ucs_cost}")

    print("\nRunning Breadth-First Search...")
    bfs_path = breadth_first_search_unweighted(graph, start, goal)
    print(f"BFS Path: {bfs_path}")


if __name__ == "__main__":
    # Define a weighted graph as an adjacency list
    # Format: node: [(neighbor, weight), ...]
    graph = {
        'A': [('B', 1), ('C', 4)],
        'B': [('A', 1), ('C', 2), ('D', 6)],
        'C': [('A', 4), ('B', 2), ('D', 3)],
        'D': [('B', 6), ('C', 3)]
    }

    start_node = 'A'
    goal_node = 'D'

    print("Graph:")
    for node, neighbors in graph.items():
        print(f"{node}: {neighbors}")

    print("\nComparison of UCS and BFS:")
    compare_ucs_and_bfs(graph, start_node, goal_node)